import java.util.Arrays;

public class PractiseQuestions {
    public static void main(String[] args) {
        // System.out.println(largestAdjacentSum(new int[] { 1, 1, 1, 1, 1, 2, 1, 1, 1
        // }));
        // System.out.println(checkConcatenatedSum(198, 2));

        // System.out.println(isSequencedArray(new int[] { -5, -5, -4, -4, -4, -3, -3,
        // -2, -2, -2 }, -5, -2));
        // System.out.println(largestPrimeFactor(10));
        // System.out.println(isSequencedArray(new int[] { 1, 2, 3, 4 }, 1, 5));
        // System.out.println(isSequencedArray(new int[] { 1, 2, 5 }, 1, 5));
        // System.out.println(isSequencedArray(new int[] { 5, 4, 3, 2, 1 }, 1, 5));

        // System.out.println(Arrays.toString(encodeNumber(6936)));
        // System.out.println(Arrays.toString(encodeNumber(2)));
        // System.out.println(Arrays.toString(encodeNumber(6)));
        // System.out.println(Arrays.toString(encodeNumber(14)));
        // System.out.println(Arrays.toString(encodeNumber(24)));
        // System.out.println(Arrays.toString(encodeNumber(1200)));
        // System.out.println(Arrays.toString(encodeNumber(1)));
        // System.out.println(Arrays.toString(encodeNumber(-18)));

        // int[] a = new int[] { 1, 2, 3, 4, 5 };
        // doIntegerBasedRounding(a, 2);
        // System.out.println(Arrays.toString(a));

        // System.out.println(isCubePowerful(-81));

        // System.out.println(decodeArray(new int[] { -1, 5, 8, 17, 15 }));

        // System.out.println(isDigitIncreasing(36));

        System.out.println(isOnionArray(new int[] { 1, 2, 19, 4, 5 }));
        System.out.println(isOnionArray(new int[] { 1, 2, 3, 4, 15 }));
        System.out.println(isOnionArray(new int[] { 1, 3, 9, 8 }));
        System.out.println(isOnionArray(new int[] { 2 }));
        System.out.println(isOnionArray(new int[] {}));
        System.out.println(isOnionArray(new int[] { -2, 5, 0, 5, 12 }));

        // System.out.println(isPrimeHappy(5));
        // System.out.println(isPrimeHappy(25));
        // System.out.println(isPrimeHappy(32));
        // System.out.println(isPrimeHappy(8));
        // System.out.println(isPrimeHappy(2));

        // System.out.println(isSystematicallyIncreasing(new int[] { 1, 1, 2, 3 }));

        // System.out.println(isFactorialPrime(2));
        // System.out.println(isFactorialPrime(3));
        // System.out.println(isFactorialPrime(7));
        // System.out.println(isFactorialPrime(8));
        // System.out.println(isFactorialPrime(11));
        // System.out.println(isFactorialPrime(721));

        // System.out.println(largestDifferenceOfEvens(new int[] { -2, 3, 4, 9 }));
        // System.out.println(largestDifferenceOfEvens(new int[] { 1, 3, 5, 9 }));
        // System.out.println(largestDifferenceOfEvens(new int[] { 1, 18, 5, 7, 33 }));
        // System.out.println(largestDifferenceOfEvens(new int[] { 2, 2, 2, 2 }));
        // System.out.println(largestDifferenceOfEvens(new int[] { 1, 2, 1, 2, 1, 4, 1,
        // 6, 4 }));

        // System.out.println(isHolderNumber(3));
        // System.out.println(isHolderNumber(7));
        // System.out.println(isHolderNumber(31));
        // System.out.println(isHolderNumber(127));

        // System.out.println(areAnagrams(new char[] { 's', 'i', 't' }, new char[] {
        // 'i', 't', 's' }));
        // System.out.println(areAnagrams(new char[]{'s', 'i', 't'}, new char[]{'i',
        // 'd', 's'}));
        // System.out.println(areAnagrams(new char[]{'b', 'i', 'g'}, new char[]{'b',
        // 'i', 't'}));
        // System.out.println(areAnagrams(new char[]{'b', 'o', 'g'}, new char[]{'b',
        // 'o', 'o'}));
        // System.out.println(areAnagrams(new char[]{}, new char[]{}));
        // System.out.println(areAnagrams(new char[]{'b', 'i', 'g'}, new char[]{'b',
        // 'i', 'g'}));

        // System.out.println(closestFibonacci(13));
        // System.out.println(closestFibonacci(12));
        // System.out.println(closestFibonacci(33));
        // System.out.println(closestFibonacci(34));

        // System.out.println(isVesuvian(50));
        // System.out.println(isVesuvian(65));
        // System.out.println(isVesuvian(85));

        // System.out.println(isOneBalanced(new int[] { 1, 1, 1, 2, 3, -18, 45, 1 }));
        // System.out.println(isOneBalanced(new int[] { 1, 1, 1, 2, 3, -18, 45, 1, 0
        // }));
        // System.out.println(isOneBalanced(new int[] { 1, 1, 2, 3, 1, -18, 26, 1 }));
        // System.out.println(isOneBalanced(new int[] {}));
        // System.out.println(isOneBalanced(new int[] { 3, 4, 1, 1 }));
        // System.out.println(isOneBalanced(new int[] { 1, 1, 3, 4 }));
        // System.out.println(isOneBalanced(new int[] { 3, 3, 3, 3, 3, 3 }));
        // System.out.println(isOneBalanced(new int[] { 1, 1, 1, 1, 1, 1 }));

        // System.out.println(isTriangular(1));
        // System.out.println(isTriangular(3));
        // System.out.println(isTriangular(4));
        // System.out.println(isTriangular(6));
        // System.out.println(isTriangular(10));
        // System.out.println(isTriangular(11));
        // System.out.println(isTriangular(12));
        // System.out.println(isTriangular(13));
        // System.out.println(isTriangular(14));
        // System.out.println(isTriangular(15));

        // System.out.println(isMercurial(new int[] { 1, 2, 10, 3, 15, 1, 2, 2 }));
        // System.out.println(isMercurial(new int[] { 5, 2, 10, 3, 15, 1, 2, 2 }));
        // System.out.println(isMercurial(new int[] { 1, 2, 10, 3, 15, 16, 2, 2 }));
        // System.out.println(isMercurial(new int[] { 3, 2, 18, 1, 0, 3, -11, 1, 3 }));
        // System.out.println(isMercurial(new int[] { 2, 3, 1, 1, 18 }));
        // System.out.println(isMercurial(new int[] { 8, 2, 1, 1, 18, 3, 5 }));
        // System.out.println(isMercurial(new int[] { 3, 3, 3, 3, 3, 3 }));
        // System.out.println(isMercurial(new int[] { 1 }));
        // System.out.println(isMercurial(new int[] {}));

        // System.out.println(is235Array(new int[] { 2, 3, 5, 7, 11 }));
        // System.out.println(is235Array(new int[] { 2, 3, 6, 7, 11 }));
        // System.out.println(is235Array(new int[] { 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
        // System.out.println(is235Array(new int[] { 2, 4, 8, 16, 32 }));
        // System.out.println(is235Array(new int[] { 3, 9, 27, 7, 1, 1, 1, 1, 1 }));
        // System.out.println(is235Array(new int[] { 7, 11, 77, 49 }));
        // System.out.println(is235Array(new int[] { 2 }));
        // System.out.println(is235Array(new int[] {}));
        // System.out.println(is235Array(new int[] { 7, 2, 7, 2, 7, 2, 7, 2, 3, 7, 7
        // }));

        // System.out.println(Arrays.toString(isComputeHMS(3735)));
        // System.out.println(Arrays.toString(isComputeHMS(3650)));

        // System.out.println(isMartian(new int[] { 1, 3 }));
        // System.out.println(isMartian(new int[] { 1, 2, 1, 2, 1, 2, 1, 2, 1 }));
        // System.out.println(isMartian(new int[] { 1, 3, 2 }));
        // System.out.println(isMartian(new int[] { 1, 3, 2, 2, 1, 5, 1, 5 }));
        // System.out.println(isMartian(new int[] { 1, 2, -18, -18, 1, 2 }));
        // System.out.println(isMartian(new int[] {}));
        // System.out.println(isMartian(new int[] { 1 }));
        // System.out.println(isMartian(new int[] { 2 }));

        // System.out.println(isPairedN(new int[] { 1, 4, 1, 4, 5, 6 }, 5));
        // System.out.println(isPairedN(new int[] { 1, 4, 1, 4, 5, 6 }, 6));
        // System.out.println(isPairedN(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, 6));
        // System.out.println(isPairedN(new int[] { 1, 4, 1 }, 5));
        // System.out.println(isPairedN(new int[] { 8, 8, 8, 8, 7, 7, 7 }, 15));
        // System.out.println(isPairedN(new int[] { 8, -8, 8, 8, 7, 7, -7 }, -15));
        // System.out.println(isPairedN(new int[] { 3 }, 3));
        // System.out.println(isPairedN(new int[] {}, 0));

        // System.out.println(isNPrimeable(new int[] { 5, 15, 27 }, 2));
        // System.out.println(isNPrimeable(new int[] { 5, 15, 27 }, 3));
        // System.out.println(isNPrimeable(new int[] { 5, 15, 26 }, 2));
        // System.out.println(isNPrimeable(new int[] { 1, 1, 1, 1, 1, 1, 1 }, 4));
        // System.out.println(isNPrimeable(new int[] {}, 2));

        // System.out.println(is121Array(new int[] { 1, 2, 1 }));
        // System.out.println(is121Array(new int[] { 1, 1, 2, 2, 2, 1, 1 }));
        // System.out.println(is121Array(new int[] { 1, 1, 2, 2, 2, 1, 1, 1 }));
        // System.out.println(is121Array(new int[] { 1, 1, 2, 1, 2, 1, 1 }));
        // System.out.println(is121Array(new int[] { 1, 1, 1, 2, 2, 2, 1, 1, 1, 3 }));
        // System.out.println(is121Array(new int[] { 1, 1, 1, 1, 1, 1 }));
        // System.out.println(is121Array(new int[] { 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1
        // }));
        // System.out.println(is121Array(new int[] { 1, 1, 1, 2, 2, 2, 1, 1, 2, 2 }));
        // System.out.println(is121Array(new int[] { 2, 2, 2 }));

        // System.out.println(Arrays.toString(pairwiseSum(new int[] { 2, 1, 18, -5 })));
        // System.out.println(Arrays.toString(pairwiseSum(new int[] { 2, 1, 18, -5, -5,
        // -15, 0, 0, 1, -1 })));
        // System.out.println(Arrays.toString(pairwiseSum(new int[] { 2, 1, 18 })));
        // System.out.println(Arrays.toString(pairwiseSum(new int[] {})));

        // System.out.println(isSquare(4));
        // System.out.println(isSquare(25));
        // System.out.println(isSquare(-4));
        // System.out.println(isSquare(8));
        // System.out.println(isSquare(0));

        // System.out.println(isComplete1(new int[] { 36, -28 }));
        // System.out.println(isComplete1(new int[] { 36, 28 }));
        // System.out.println(isComplete1(new int[] { 4 }));
        // System.out.println(isComplete1(new int[] { 3, 2, 1, 1, 5, 6 }));
        // System.out.println(isComplete1(new int[] { 3, 7, 23, 13, 107, -99, 97, 81
        // }));

        // System.out.println(loopSum(new int[] { 1, 2, 3 }, 2));
        // System.out.println(loopSum(new int[] { -1, 2, -1 }, 7));
        // System.out.println(loopSum(new int[] { 1, 4, 5, 6 }, 4));
        // System.out.println(loopSum(new int[] { 3 }, 10));

        // System.out.println(allValuesTheSame(new int[] { 1, 1, 1, 1 }));
        // System.out.println(allValuesTheSame(new int[] { 83, 83, 83 }));
        // System.out.println(allValuesTheSame(new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // 0 }));
        // System.out.println(allValuesTheSame(new int[] { 1, -2343456, 1, -2343456 }));
        // System.out.println(allValuesTheSame(new int[] { 0, 0, 0, 0, -1 }));
        // System.out.println(allValuesTheSame(new int[] { 432123456 }));
        // System.out.println(allValuesTheSame(new int[] { -432123456 }));
        // System.out.println(allValuesTheSame(new int[] {}));

        // System.out.println(hasNValues(new int[] { 1, 2, 2, 1 }, 2));
        // System.out.println(hasNValues(new int[] { 1, 1, 1, 8, 1, 1, 1, 3, 3 }, 3));
        // System.out.println(hasNValues(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
        // 10));
        // System.out.println(hasNValues(new int[] { 1, 2, 2, 1 }, 3));
        // System.out.println(hasNValues(new int[] { 1, 1, 1, 8, 1, 1, 1, 3, 3 }, 2));
        // System.out.println(hasNValues(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
        // 20));

        // System.out.println(sameNumberOfFactors(-6, 21));
        // System.out.println(sameNumberOfFactors(6, 21));
        // System.out.println(sameNumberOfFactors(8, 12));
        // System.out.println(sameNumberOfFactors(23, 97));
        // System.out.println(sameNumberOfFactors(0, 1));
        // System.out.println(sameNumberOfFactors(0, 0));

        // System.out.println(eval(1.0, new int[] { 0, 1, 2, 3, 4 }));
        // System.out.println(eval(3.0, new int[] { 3, 2, 1 }));
        // System.out.println(eval(2.0, new int[] { 3, -2, -1 }));
        // System.out.println(eval(-3.0, new int[] { 3, 2, 1 }));
        // System.out.println(eval(2.0, new int[] { 3, 2 }));
        // System.out.println(eval(2.0, new int[] { 4, 0, 9 }));
        // System.out.println(eval(2.0, new int[] { 10 }));
        // System.out.println(eval(10.0, new int[] { 0, 1 }));

        // System.out.println(isAllPossibilities(new int[] { 1, 2, 0, 3 }));
        // System.out.println(isAllPossibilities(new int[] { 3, 2, 1, 0 }));
        // System.out.println(isAllPossibilities(new int[] { 1, 2, 4, 3 }));
        // System.out.println(isAllPossibilities(new int[] { 0, 2, 3 }));
        // System.out.println(isAllPossibilities(new int[] { 0 }));
        // System.out.println(isAllPossibilities(new int[] {}));

        // System.out.println(isLayered(new int[] { 1, 1, 2, 2, 2, 3, 3 }));
        // System.out.println(isLayered(new int[] { 3, 3, 3, 3, 3, 3, 3 }));
        // System.out.println(isLayered(new int[] { 1, 2, 2, 2, 3, 3 }));
        // System.out.println(isLayered(new int[] { 2, 2, 2, 3, 3, 1, 1 }));
        // System.out.println(isLayered(new int[] { 2 }));
        // System.out.println(isLayered(new int[] {}));

        // int[] d = new int[] { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 };
        // updateMileageCounter(d, 13);

        // System.out.println(Arrays.toString(d));

        // System.out.println(isHollow(new int[] { 1, 2, 0, 0, 0, 3, 4 }));
        // System.out.println(isHollow(new int[] { 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 1, 2,
        // 18 }));
        // System.out.println(isHollow(new int[] { 1, 2, 0, 0, 3, 4 }));
        // System.out.println(isHollow(new int[] { 1, 2, 0, 0, 0, 3, 4, 5 }));
        // System.out.println(isHollow(new int[] { 3, 8, 3, 0, 0, 0, 3, 3 }));
        // System.out.println(isHollow(new int[] { 1, 2, 0, 0, 0, 3, 4, 0 }));
        // System.out.println(isHollow(new int[] { 0, 1, 2, 0, 0, 0, 3, 4 }));
        // System.out.println(isHollow(new int[] { 0, 0, 0 }));

        // System.out.println(isConsecutiveFactored(24));
        // System.out.println(isConsecutiveFactored(105));
        // System.out.println(isConsecutiveFactored(90));
        // System.out.println(isConsecutiveFactored(23));
        // System.out.println(isConsecutiveFactored(15));
        // System.out.println(isConsecutiveFactored(2));
        // System.out.println(isConsecutiveFactored(0));
        // System.out.println(isConsecutiveFactored(-12));

        // System.out.println(isTwinPrime(5));
        // System.out.println(isTwinPrime(7));
        // System.out.println(isTwinPrime(53));
        // System.out.println(isTwinPrime(9));

        // System.out.println(isZeroBalanced(new int[] { 1, 2, -2, -1 }));
        // System.out.println(isZeroBalanced(new int[] { -3, 1, 2, -2, -1, 3 }));
        // System.out.println(isZeroBalanced(new int[] { 3, 4, -2, -3, -2 }));
        // System.out.println(isZeroBalanced(new int[] { 0, 0, 0, 0, 0, 0 }));
        // System.out.println(isZeroBalanced(new int[] { 3, -3, -3 }));
        // System.out.println(isZeroBalanced(new int[] { 3 }));
        // System.out.println(isZeroBalanced(new int[] {}));

    }

    static int isZeroBalanced(int[] a) {
        if (a.length <= 1 || a.length % 2 != 0) {
            return 0;
        }
        boolean flag = false;
        for (int index = 0, j = a.length - 1; index < j; index++, j--) {
            if (a[index] + a[j] == 0) {
                flag = true;
            }
        }
        if (flag) {
            return 1;
        }
        return 0;
    }

    static int isTwinPrime(int n) {

        if (isPrime(n)) {
            if (isPrime(n + 2) || isPrime(n - 2)) {
                return 1;
            }
        }
        return 0;

    }

    static int isConsecutiveFactored(int n) {
        for (int i = 2; i < n; i++) {
            if (n % i == 0 && n % (i + 1) == 0)
                return 1;
        }
        return 0;
    }

    static int isHollow(int[] a) {
        if (a.length < 3)
            return 0;
        int zeroCount = 0;

        for (int i = 0, j = a.length - 1; i <= j; i++, j--) {
            if ((a[i] == 0 && a[j] != 0) || (a[i] != 0 && a[j] == 0)) {
                return 0;
            }
            if (i == j && a[i] == 0) {
                zeroCount++;
            } else {
                if (a[i] == 0)
                    zeroCount++;

                if (a[j] == 0)
                    zeroCount++;
            }
        }

        if (zeroCount >= 3)
            return 1;
        return 0;
    }

    static void updateMileageCounter(int[] a, int miles) {
        for (int i = 0; i < a.length && miles > 0; i++) {
            miles = a[i] + miles;
            if (miles > 9) {
                int tempMiles = miles % 10;
                miles /= 10;
                a[i] = tempMiles;
            } else {
                a[i] = miles;
                miles = 0;
            }
        }
    }

    static int isLayered(int[] a) {
        if (a.length <= 1)
            return 0;

        int count = 1;
        for (int i = 0; i < a.length - 1; i++) {
            if (a[i] > a[i + 1])
                return 0;

            if (a[i] == a[i + 1])
                count++;

            if (a[i] != a[i + 1]) {
                if (count < 2)
                    return 0;
                count = 1;
            }
        }
        return 1;
    }

    static int isAllPossibilities(int[] a) {
        if (a.length <= 0)
            return 0;

        for (int i = 0; i < a.length; i++) {
            boolean flag = false;
            for (int anA : a) {
                if (anA == i) {
                    flag = true;
                    break;
                }
            }
            if (!flag)
                return 0;
        }
        return 1;
    }

    static double eval(double x, int[] a) {
        double sum = 0;

        for (int i = 0; i < a.length; i++) {
            double product = 1;
            for (int j = 0; j < i; j++) {
                product *= x;
            }
            sum += a[i] * product;
        }

        return sum;
    }

    static int sameNumberOfFactors(int n1, int n2) {
        if (n1 < 0 || n2 < 0)
            return -1;

        if (n1 == n2)
            return 1;

        int countOfFactor1 = 0;
        int countOfFactor2 = 0;

        for (int i = 1; i <= n1; i++) {
            if (n1 % i == 0)
                countOfFactor1++;
        }

        for (int j = 1; j <= n2; j++) {
            if (n2 % j == 0)
                countOfFactor2++;
        }

        if (countOfFactor1 == countOfFactor2)
            return 1;
        return 0;
    }

    static int hasNValues(int[] a, int n) {

        if (a.length < n)
            return 0;

        int[] uniqueArray = new int[n];
        int totalAdded = 0;
        boolean uniqueFlag;

        for (int anA : a) {
            uniqueFlag = false;
            for (int anUnique : uniqueArray) {
                if (anA == anUnique) {
                    uniqueFlag = true;
                    break;
                }
            }
            if (!uniqueFlag) {
                if (totalAdded >= n)
                    return 0;
                uniqueArray[totalAdded] = anA;
                totalAdded++;
            }
        }

        if (totalAdded == n)
            return 1;
        return 0;
    }

    static int allValuesTheSame(int[] a) {
        if (a.length <= 0)
            return 0;

        for (int i = 0; i < a.length - 1; i++) {
            if (a[i] != a[i + 1])
                return 0;
        }
        return 1;
    }

    static int loopSum(int[] a, int n) {
        int sum = 0;

        for (int i = 0, index = 0; i < a.length && index < n; i++, index++) {
            sum += a[i];
            if (i == a.length - 1 && index != n - 1)
                i = -1;
        }
        return sum;
    }

    static int isComplete1(int[] a) {
        boolean squareFlag = false;
        boolean evenFlag = false;
        boolean sumFlag = false;
        for (int i = 0; i < a.length; i++) {
            if (a[i] % 2 == 0)
                evenFlag = true;

            if (a[i] != 1 && IsSquare.isSquare(a[i]) == 1)
                squareFlag = true;

            for (int j = i + 1; j < a.length; j++) {
                if (a[i] + a[j] == 8) {
                    sumFlag = true;
                    break;
                }
            }

            if (evenFlag && squareFlag && sumFlag)
                return 1;
        }

        return 0;
    }

    static int isSquare(int n) {
        if (n < 0)
            return 0;

        int square = 0;
        int number = 1;

        while (square < n) {
            square = number * number;
            number++;
        }

        if (square == n)
            return 1;

        return 0;
    }

    static int[] pairwiseSum(int[] a) {
        if (a.length <= 0 && a.length % 2 != 0) {
            return null;
        }

        int[] result = new int[a.length / 2];

        for (int index = 0, i = 0; index <= result.length && i < a.length - 1; i = i + 2, index++) {
            result[index] = a[i] + a[i + 1];
        }

        return result;
    }

    static int is121Array(int[] a) {
        if (a[0] != 1 || a[a.length - 1] != 1)
            return 0;

        int i, j;
        boolean flag = false;
        for (i = 0, j = a.length - 1; i < a.length && j >= 0 && i <= j; i++, j--) {
            if (a[i] != 1 || a[j] != 1) {
                if (a[i] != 2 || a[j] != 2)
                    return 0;
                else {
                    flag = true;
                    break;
                }
            }
        }

        for (int index = i; index <= j; index++) {
            if (a[index] != 2)
                return 0;
        }

        if (flag)
            return 1;
        return 0;
    }

    static int isNPrimeable(int[] a, int n) {
        for (int i = 0; i < a.length; i++) {
            if (!isPrime(a[i] + n))
                return 0;
        }
        return 1;
    }

    static int isPairedN(int[] a, int n) {

        if (a.length <= 1 || n > a.length + 1 || n < 0)
            return 0;

        for (int i = 0; i < a.length; i++) {
            for (int j = i + 1; j < a.length; j++) {
                if (a[i] + a[j] == n && i + j == n) {
                    return 1;
                }
            }
        }
        return 0;
    }

    static int isMartian(int[] a) {
        int countOf1 = 0;
        int countOf2 = 0;

        for (int i = 0; i < a.length; i++) {
            if (i < a.length - 1 && a[i] == a[i + 1]) {
                return 0;
            }

            if (a[i] == 1)
                countOf1++;

            if (a[i] == 2)
                countOf2++;
        }

        if (countOf1 > countOf2)
            return 1;
        return 0;
    }

    static int[] isComputeHMS(int seconds) {
        int[] result = new int[3];
        int s = seconds / 3600;
        result[0] = s;
        int m = (seconds % 3600) / 60;
        result[1] = m;
        int h = seconds % 60;
        result[2] = h;
        return result;
    }

    static int is235Array(int[] a) {
        int divisibleBy2 = 0;
        int divisibleBy3 = 0;
        int divisibleBy5 = 0;

        int notDivisible = 0;

        for (int i = 0; i < a.length; i++) {
            if (a[i] % 2 == 0 || a[i] % 3 == 0 || a[i] % 5 == 0) {
                if (a[i] % 2 == 0)
                    divisibleBy2++;
                if (a[i] % 3 == 0)
                    divisibleBy3++;
                if (a[i] % 5 == 0)
                    divisibleBy5++;
            } else {
                notDivisible++;
            }
        }

        if (divisibleBy2 + divisibleBy3 + divisibleBy5 + notDivisible == a.length)
            return 1;
        return 0;
    }

    static int isMercurial(int[] a) {

        boolean precedingOneFlag = false;

        int indexOf3 = -1;
        int indexOf1 = -1;
        for (int i = 0; i < a.length; i++) {
            if (a[i] == 1)
                indexOf1 = i;

            if (a[i] == 3) {
                indexOf3 = i;
            }

            if (indexOf1 != -1 && indexOf3 > indexOf1)
                precedingOneFlag = true;

            if (precedingOneFlag && a[i] == 1)
                return 0;
        }

        return 1;
    }

    static int isTriangular(int n) {

        int sum = 0;
        for (int i = 1; sum < n; i++) {
            sum += i;
        }
        if (sum == n)
            return 1;
        return 0;
    }

    static int isOneBalanced(int[] a) {
        int total1s = 0;
        int totalNon1s = 0;
        boolean non1Start = false;
        boolean non1End = false;
        if (a.length == 0)
            return 1;
        for (int number : a) {
            if (number == 1) {
                if (non1Start)
                    non1End = true;
                total1s++;
            } else {
                if (non1End)
                    return 0;
                non1Start = true;
                totalNon1s++;
            }
        }
        if (total1s != totalNon1s)
            return 0;
        return 1;
    }

    static int isVesuvian(int n) {
        int count = 0;
        for (int i = 1; (i * i) < n; i++) {
            int sum1 = i * i;
            for (int j = 1; (j * j) < n; j++) {
                int sum2 = j * j;
                if (sum1 + sum2 == n) {
                    count++;
                    break;
                }
            }
            if (count >= 2)
                return 1;
        }
        return 0;
    }

    static int closestFibonacci(int n) {
        int fibonacci = 1;
        if (n == 1 || n == 2) {
            fibonacci = 1;
        }
        int fibo1 = 1;
        int fibo2 = 1;
        for (int i = 3; i <= n; i++) {
            fibonacci = fibo1 + fibo2; // Fibonacci number is sum of previous two Fibonacci number
            if (fibonacci > n)
                return fibo2;
            fibo1 = fibo2;
            fibo2 = fibonacci;

        }

        return 0;
    }

    static int areAnagrams(char[] a1, char[] a2) {
        if (a1.length != a2.length)
            return 0;

        char[] a1Copy = new char[a1.length];
        char[] a2Copy = new char[a2.length];

        for (int i = 0; i < a1.length; i++) {
            a1Copy[i] = a1[i];
            a2Copy[i] = a2[i];
        }

        for (int i = 0; i < a1Copy.length; i++) {
            for (int j = 0; j < a2Copy.length; j++) {
                if (a1Copy[i] == a2Copy[j]) {
                    a1Copy[i] = ' ';
                    a2Copy[j] = ' ';
                }
            }
        }

        for (int i = 0; i < a1Copy.length; i++) {
            if (a1Copy[i] != ' ' || a2Copy[i] != ' ')
                return 0;
        }

        return 1;
    }

    static int isHolderNumber(int n) {
        if (isPrime(n)) {
            int number = 0, product = 1;

            while (number < n) {
                product *= 2;
                number = product - 1;
            }

            if (n == number) {
                return 1;
            }
            return 0;
        }

        return 0;
    }

    static int largestDifferenceOfEvens(int[] a) {
        boolean evenFlag = false;
        int largestDiff = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i] % 2 == 0) {
                for (int j = i + 1; j < a.length; j++) {
                    if (a[j] % 2 == 0) {
                        evenFlag = true;
                        int diff = a[i] > a[j] ? a[i] - a[j] : a[j] - a[i];
                        largestDiff = diff > largestDiff ? diff : largestDiff;
                    }
                }
            }
            if (!evenFlag && i == a.length - 1)
                return -1;
        }

        return largestDiff;
    }

    static int isFactorialPrime(int n) {
        if (isPrime(n)) {
            int sum = 0;
            for (int index = 0; index < n && sum < n; index++) {
                sum = factorial(index) + 1;
            }
            if (sum == n) {
                return 1;
            } else {
                return 0;
            }
        }

        return 0;
    }

    static int factorial(int n) {
        if (n == 1 || n == 0) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

    static int isSystematicallyIncreasing(int[] a) {
        int j = 1;
        for (int i = 0; i < a.length; i++) {
            if (a[i] != j) {
                return 0;
            }
            j++;

        }

        return 1;
    }

    static int isPrimeHappy(int n) {
        int number = 2;
        boolean primeFlag = false;
        int sum = 0;
        while (number < n) {
            if (isPrime(number)) {
                primeFlag = true;
                sum += number;
            }
            number++;
        }
        if (primeFlag && sum % n == 0)
            return 1;
        else
            return 0;
    }

    static int isPrimeHappy2(int n) {
        int sumPrime = 0;
        if (n <= 2) {
            return 0;
        }
        for (int i = 2; i < n; i++) {
            if (isPrime(i)) {
                sumPrime += i;
            }
        }
        if (sumPrime % n != 0) {
            return 0;
        }

        return 1;
    }

    static int isOnionArray(int[] a) {
        if (a.length < 2) {
            return 1;
        }
        for (int j = 0, k = a.length - 1; j < k; j++, k--) {
            if (a[j] + a[k] > 10 && j + k == a.length - 1) {
                return 0;
            }
        }
        return 1;
    }

    static int isOnionArray1(int[] a) {
        if (a.length < 2) {
            return 1;
        }
        int i = 0;
        int j = a.length - 1;
        while (j > i) {
            if (a[i] + a[j] > 10 && j + i == a.length - 1) {
                return 0;
            }
            i++;
            j--;
        }
        return 1;
    }

    static int isDigitIncreasing(int n) {

        for (int index = 1; index < 9; index++) {
            int product = 0;
            int sum = 0;
            while (sum < n) {
                product = product * 10 + index;
                sum += product;
            }

            if (sum == n) {
                return 1;
            }
        }
        return 0;
    }

    static int decodeArray(int[] a) {
        String res = "";
        for (int i = 1; i < a.length; i++) {
            res += Math.abs(a[i - 1] - a[i]);
        }
        if (a[0] < 0) {
            res = "-" + res;
        }

        return Integer.valueOf(res);
    }

    static int isCubePowerful(int n) {
        if (n <= 1) {
            return 0;
        }
        int nCopy = n;
        int sum = 0;
        while (nCopy != 0) {
            int digit = nCopy % 10;
            int sqrtValue = 1;

            for (int i = 0; i < 3; i++) {
                sqrtValue *= digit;
            }
            sum += sqrtValue;
            nCopy /= 10;
        }

        if (sum != n) {
            return 0;
        }
        return 1;
    }

    static void doIntegerBasedRounding(int[] a, int n) {
        if (n > 0) {
            for (int i = 0; i < a.length; i++) {
                if (a[i] > 0) {
                    int base = n * (a[i] / n);
                    a[i] = Math.abs(a[i] - base) < Math.abs(a[i] - base - n) ? base : base + n;
                }

            }
        }
    }

    static int largestAdjacentSum(int[] a) {
        int result = 0;

        for (int i = 0; i < a.length - 1; i++) {
            if (a[i] + a[i + 1] > result) {
                result = a[i] + a[i + 1];
            }
        }
        return result;
    }

    static int checkConcatenatedSum(int n, int catlen) {
        int tempN = n, sumResult = 0;
        while (tempN > 0) {
            int remain = tempN % 10;
            int catlenSum = 0;
            for (int i = 0; i < catlen; i++) {
                catlenSum = catlenSum * 10 + remain;
            }
            sumResult += catlenSum;
            tempN /= 10;
        }
        return n == sumResult ? 1 : 0;
    }

    static int isSequencedArray(int[] a, int m, int n) {
        if (a.length <= 1 || a[0] != m || a[a.length - 1] != n || m > n)
            return 0;

        for (var i = m; i < n; i++) {
            boolean flag = false;

            for (int j = 1; j < a.length - 1; j++) {
                if (a[j - 1] > a[j]) {
                    return 0;
                }
                if (a[j - 1] == i || a[j] == i) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                return 0;
            }

        }

        return 1;
    }

    static int largestPrimeFactor(int n) {
        if (n <= 1) {
            return 0;
        }
        int largestPrimeFactor = 2;
        for (int i = 2; i < n; i++) {
            if (n % i == 0 && isPrime(i)) {
                largestPrimeFactor = i;
            }

        }

        return largestPrimeFactor;
    }

    static boolean isPrime(int n) {
        for (int i = 2; i < n; i++) {
            if (n % i == 0)
                return false;
        }

        return n > 0;
    }

    static int[] encodeNumber(int n) {

        if (n <= 1)
            return null;

        int size = 0;
        int nCopy = n;
        for (int i = 2; i <= nCopy;) {
            if (isPrime(i) && nCopy % i == 0) {
                size++;
                nCopy /= i;
            } else
                i++;
        }

        int[] result = new int[size];
        nCopy = n;

        for (int i = 0, j = 2; i < size && j <= nCopy;) {
            if (isPrime(j) && nCopy % j == 0) {
                result[i] = j;
                i++;
                nCopy /= j;
            } else
                j++;
        }

        return result;
    }

}
